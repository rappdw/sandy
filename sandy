#!/usr/bin/env bash
set -euo pipefail

# =============================================================================
# sandy — Claude's isolated sibling
#
# Runs Claude Code in a Docker container with:
#   - Filesystem: read/write limited to current directory only
#   - Network: public internet only, NO LAN access
#   - Resources: capped CPU and memory
#   - Per-project sandbox: isolated ~/.claude per working directory
#
# Usage:
#   sandy                     Start interactive session
#   sandy -p "prompt"         One-shot prompt
# =============================================================================

SANDY_VERSION="0.2.0"

SANDY_HOME="${SANDY_HOME:-$HOME/.sandy}"
# Validate SANDY_HOME — reject shell metacharacters
if [[ "$SANDY_HOME" =~ [\;\$\`\&\|\<\>] ]]; then
    echo "[sandy] ERROR: Invalid SANDY_HOME: contains shell metacharacters" >&2
    exit 1
fi
IMAGE_NAME="sandy-claude-code"
# Per-instance network names keyed on PID to avoid concurrent iptables races
BRIDGE_NAME="br-claude-$$"
NETWORK_NAME="sandy_net_$$"

# --- Colors (disabled when not a terminal) ---
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' NC=''
fi

info()  { echo -e "${GREEN}[sandy]${NC} $*"; }
warn()  { echo -e "${YELLOW}[sandy]${NC} $*"; }
error() { echo -e "${RED}[sandy]${NC} $*" >&2; }

# --- Version ---
if [[ "${1:-}" == "-v" || "${1:-}" == "--version" ]]; then
    echo "sandy $SANDY_VERSION"
    exit 0
fi

# --- Help ---
if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    cat <<EOF
sandy $SANDY_VERSION — Claude's isolated sibling

Run Claude Code in a Docker container with filesystem isolation,
network isolation, resource limits, and per-project credential sandboxes.

Usage:
  sandy                          Start interactive session
  sandy -p "prompt"              One-shot prompt
  sandy --help                   Show this help

Environment variables:
  SANDY_MODEL        Model to use (default: claude-opus-4-6)
  ANTHROPIC_API_KEY  API key (not needed with Claude Max / OAuth)
  SANDY_HOME         Sandy config directory (default: ~/.sandy)
  SANDY_SSH          Git SSH method: "token" (default) uses gh CLI token
                     with HTTPS; "agent" forwards host SSH agent via relay
  SANDY_SKIP_PERMISSIONS  Set to "false" to keep Claude Code's permission
                     system active (default: "true" — bypasses permissions)
  SANDY_ALLOW_NO_ISOLATION  Set to "1" to allow launch when iptables
                     rules cannot be applied (Linux only)

Flags:
  --help             Show this help
  --version          Show version
  --rebuild          Force rebuild of the sandbox Docker image

All other arguments are forwarded to claude.
EOF
    exit 0
fi

# --- --rebuild flag ---
SANDY_REBUILD=false
if [[ "${1:-}" == "--rebuild" ]]; then
    SANDY_REBUILD=true
    shift
fi

# --- Preflight checks ---
if ! command -v docker &>/dev/null; then
    error "Docker is not installed or not in PATH."
    exit 1
fi

# --- Ensure SANDY_HOME and build files exist ---
ensure_build_files() {
    mkdir -p "$SANDY_HOME"

    cat > "$SANDY_HOME/Dockerfile.new" <<'DOCKERFILE'
FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y ca-certificates curl git gosu jq less openssh-client ripgrep socat tmux ncurses-term && rm -rf /var/lib/apt/lists/*
ENV LANG=C.UTF-8
ENV LC_ALL=C.UTF-8
RUN useradd -m -s /bin/bash -u 1001 claude
ENV PATH="/home/claude/.local/bin:$PATH"
# Install Claude Code natively. The installer places the binary under
# /home/claude/.local/share/claude/versions/<ver> with symlinks from
# ~/.local/bin/claude.  We dereference (-L) the symlink chain to copy
# the real binary to /usr/local/bin so it survives the tmpfs overlay
# on /home/claude at runtime.
RUN HOME=/home/claude su -s /bin/bash claude -c "curl -fsSL https://claude.ai/install.sh | bash" \
 && cp -L /home/claude/.local/bin/claude /usr/local/bin/claude \
 && rm -rf /home/claude/.local/share/claude
COPY tmux.conf /etc/tmux.conf
COPY entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh
WORKDIR /workspace
ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
DOCKERFILE

    cat > "$SANDY_HOME/entrypoint.sh.new" <<'ENTRYPOINT'
#!/bin/bash
# --- Root-only setup (runs before dropping to user claude) ---

# Seed known_hosts from host if available
if [ -f "/tmp/host-ssh-known_hosts" ]; then
    mkdir -p /home/claude/.ssh
    cp /tmp/host-ssh-known_hosts /home/claude/.ssh/known_hosts
    chown -R claude:claude /home/claude/.ssh
    chmod 700 /home/claude/.ssh
    chmod 644 /home/claude/.ssh/known_hosts
fi

if [ "${SANDY_SSH:-token}" = "agent" ]; then
    # --- SSH agent mode ---
    # SSH agent relay: create a Unix socket that relays to the host's TCP relay
    if [ -n "${SSH_RELAY_PORT:-}" ]; then
        rm -f /tmp/ssh-agent.sock
        socat UNIX-LISTEN:/tmp/ssh-agent.sock,fork,mode=0600,user=claude \
              TCP:host.docker.internal:${SSH_RELAY_PORT} &
        # Wait for socket to appear
        for i in $(seq 1 50); do [ -S /tmp/ssh-agent.sock ] && break; sleep 0.1; done
        export SSH_AUTH_SOCK=/tmp/ssh-agent.sock
    elif [ -S "/tmp/ssh-agent.sock" ]; then
        # Linux: socket was mounted directly
        chmod 600 /tmp/ssh-agent.sock && chown claude:claude /tmp/ssh-agent.sock
    fi

    # Copy host SSH config/keys with correct ownership and permissions
    if [ -d "/tmp/host-ssh" ]; then
        mkdir -p /home/claude/.ssh
        cp -a /tmp/host-ssh/. /home/claude/.ssh/
        chown -R claude:claude /home/claude/.ssh
        chmod 700 /home/claude/.ssh
        chmod 600 /home/claude/.ssh/* 2>/dev/null || true
        chmod 644 /home/claude/.ssh/*.pub 2>/dev/null || true
        chmod 644 /home/claude/.ssh/known_hosts 2>/dev/null || true
        chmod 644 /home/claude/.ssh/config 2>/dev/null || true
    fi
fi

# Create native install symlink so Claude Code finds its binary at the expected path
# (the real binary lives in /usr/local/bin; /home/claude is a tmpfs overlay)
mkdir -p /home/claude/.local/bin
ln -sf /usr/local/bin/claude /home/claude/.local/bin/claude
chown -R claude:claude /home/claude/.local

# Drop privileges and continue as user claude
exec gosu claude bash -c '
set -e
export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1
export DISABLE_AUTOUPDATER=1
export DISABLE_SPINNER_TIPS=1

# Remap ANSI dark blue (color 4) to a readable bright blue
printf "\033]4;4;rgb:61/8f/ff\033\\"
trap "printf \"\033]104;4\033\\\\\"" EXIT

# Ensure project-level settings exist
WORKSPACE="${SANDY_WORKSPACE:-/workspace}"
mkdir -p "$WORKSPACE/.claude" 2>/dev/null || true

# Trust the mounted workspace (host UID differs from container UID)
git config --global --add safe.directory "$WORKSPACE"

# Set git identity from host
if [ -n "${GIT_USER_NAME:-}" ]; then
    git config --global user.name "$GIT_USER_NAME"
fi
if [ -n "${GIT_USER_EMAIL:-}" ]; then
    git config --global user.email "$GIT_USER_EMAIL"
fi

# Configure git auth: GitHub token (default) or SSH agent
if [ "${SANDY_SSH:-token}" = "token" ] && [ -n "${GIT_TOKEN:-}" ]; then
    git config --global url."https://oauth2:${GIT_TOKEN}@github.com/".insteadOf "git@github.com:"
    git config --global --add url."https://oauth2:${GIT_TOKEN}@github.com/".insteadOf "ssh://git@github.com/"
fi

# Build the claude command with any passed args
CLAUDE_CMD="claude --model ${SANDY_MODEL:-claude-opus-4-6} --teammate-mode tmux"
if [ "${SANDY_SKIP_PERMISSIONS:-true}" = "true" ]; then
    CLAUDE_CMD+=" --dangerously-skip-permissions"
fi
for arg in "$@"; do
    CLAUDE_CMD+=" $(printf "%q" "$arg")"
done

cd "$WORKSPACE"
tmux new-session -s sandy -- bash -c "$CLAUDE_CMD"
' -- "$@"
ENTRYPOINT

    cat > "$SANDY_HOME/tmux.conf.new" <<'TMUXCONF'
set -g history-limit 10000
set -g mouse on
set -g default-terminal "tmux-256color"
set -as terminal-features ",tmux-256color:RGB"
set -as terminal-overrides ",*:U8=1"
set -sg escape-time 0

# Pane borders — clean single-line, short labels
set -g pane-border-lines single
set -g pane-border-style "fg=colour240"
set -g pane-active-border-style "fg=colour51"
set -g pane-border-status top
set -g pane-border-format " #[fg=colour51]#{pane_index}#[default] "

# Status bar
set -g status-position bottom
set -g status-style "bg=colour235,fg=colour248"
set -g status-left "#[fg=colour51,bold] sandy "
set -g status-left-length 10
set -g status-right "#[fg=colour248] %H:%M "
set -g status-right-length 10

# Better redraw behavior
set -g focus-events on
setw -g aggressive-resize on
TMUXCONF

    # Only update on-disk files if content has changed
    local changed=false
    for f in Dockerfile entrypoint.sh tmux.conf; do
        if [ ! -f "$SANDY_HOME/$f" ] || ! diff -q "$SANDY_HOME/$f.new" "$SANDY_HOME/$f" &>/dev/null; then
            mv "$SANDY_HOME/$f.new" "$SANDY_HOME/$f"
            changed=true
        else
            rm "$SANDY_HOME/$f.new"
        fi
    done
    if [ "$changed" = true ]; then
        info "Build files updated."
    fi
}

# --- Initialize ---
ensure_build_files

# Apply --rebuild flag (must come after ensure_build_files creates SANDY_HOME)
if [ "$SANDY_REBUILD" = true ]; then
    rm -f "$SANDY_HOME/.build_hash"
    info "Build cache cleared. Image will be rebuilt."
fi

# --- Detect available resources ---
AVAILABLE_CPUS="$(docker info --format '{{.NCPU}}' 2>/dev/null || echo 2)"
AVAILABLE_MEM_GB="$(docker info --format '{{.MemTotal}}' 2>/dev/null | awk '{printf "%d", $1/1073741824}')"
# Validate: must be a positive integer, default to 4 on parse failure
if ! [[ "$AVAILABLE_MEM_GB" =~ ^[0-9]+$ ]] || [ "$AVAILABLE_MEM_GB" -eq 0 ]; then
    AVAILABLE_MEM_GB=4
fi
SANDY_CPUS="$AVAILABLE_CPUS"
SANDY_MEM="$(( AVAILABLE_MEM_GB > 2 ? AVAILABLE_MEM_GB - 1 : 2 ))g"

# --- Build image (skip if up to date) ---
BUILD_HASH="$(cat "$SANDY_HOME/Dockerfile" "$SANDY_HOME/entrypoint.sh" "$SANDY_HOME/tmux.conf" | { shasum -a 256 2>/dev/null || sha256sum; } | cut -d' ' -f1)"
HASH_FILE="$SANDY_HOME/.build_hash"
NEEDS_BUILD=false
if [ ! -f "$HASH_FILE" ] || [ "$(cat "$HASH_FILE")" != "$BUILD_HASH" ] || ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
    NEEDS_BUILD=true
fi

# Check for newer Claude Code (skip if already rebuilding)
if [ "$NEEDS_BUILD" = false ]; then
    INSTALLED_VERSION="$(docker run --rm --entrypoint claude "$IMAGE_NAME" --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || true)"
    LATEST_VERSION="$(curl -fsSL https://storage.googleapis.com/claude-code-dist-86c565f3-f756-42ad-8dfa-d59b1c096819/claude-code-releases/latest 2>/dev/null || true)"
    if [ -n "$LATEST_VERSION" ] && [ -n "$INSTALLED_VERSION" ] && [ "$LATEST_VERSION" != "$INSTALLED_VERSION" ]; then
        info "Claude Code update available: $INSTALLED_VERSION → $LATEST_VERSION"
        NEEDS_BUILD=true
    fi
fi

if [ "$NEEDS_BUILD" = true ]; then
    info "Building sandbox image..."
    docker build -q --no-cache -t "$IMAGE_NAME" "$SANDY_HOME"
    echo "$BUILD_HASH" > "$HASH_FILE"
else
    info "Sandbox image up to date."
fi

# --- Ensure the per-instance isolated network exists ---
CONTAINER_SUBNET=""
ensure_network() {
    info "Creating isolated network..."
    docker network create \
        --driver bridge \
        --ipv6=false \
        -o com.docker.network.bridge.name="$BRIDGE_NAME" \
        "$NETWORK_NAME" >/dev/null
    # Query the dynamically-assigned subnet and bridge name
    CONTAINER_SUBNET="$(docker network inspect "$NETWORK_NAME" --format '{{(index .IPAM.Config 0).Subnet}}')"
    BRIDGE_NAME="$(docker network inspect "$NETWORK_NAME" --format '{{index .Options "com.docker.network.bridge.name"}}')"
}

ensure_network

# --- Per-project sandbox directory ---
WORK_DIR="$(pwd)"
FULL_HASH="$(printf '%s' "$WORK_DIR" | { shasum -a 256 2>/dev/null || sha256sum; })"
FULL_HASH="${FULL_HASH%% *}"
SHORT_HASH="${FULL_HASH:0:8}"
# Sanitize the directory basename for use in the sandbox name
DIR_BASE="$(basename "$WORK_DIR" | tr -cd 'a-zA-Z0-9._-')"
DIR_BASE="${DIR_BASE:-project}"
SANDBOX_NAME="${DIR_BASE}-${SHORT_HASH}"
SANDBOX_DIR="$SANDY_HOME/sandboxes/${SANDBOX_NAME}"

# Migrate legacy hash-only sandbox if it exists
LEGACY_SANDBOX="$SANDY_HOME/sandboxes/${FULL_HASH}"
if [ -d "$LEGACY_SANDBOX" ] && [ ! -d "$SANDBOX_DIR" ]; then
    info "Migrating sandbox: ${FULL_HASH} → ${SANDBOX_NAME}"
    mv "$LEGACY_SANDBOX" "$SANDBOX_DIR"
    # Migrate the companion .claude.json too
    if [ -f "$LEGACY_SANDBOX.claude.json" ]; then
        mv "$LEGACY_SANDBOX.claude.json" "$SANDY_HOME/sandboxes/${SANDBOX_NAME}.claude.json"
    fi
fi

if [ ! -d "$SANDBOX_DIR" ]; then
    info "Creating new sandbox: $SANDBOX_DIR"
    mkdir -p "$SANDBOX_DIR"
    # Seed settings from host's ~/.claude if available
    if [ -f "$HOME/.claude/settings.json" ]; then
        cp "$HOME/.claude/settings.json" "$SANDBOX_DIR/settings.json"
        info "  Seeded settings.json"
    fi
    # Seed statsig cache for feature flags
    if [ -d "$HOME/.claude/statsig" ]; then
        cp -r "$HOME/.claude/statsig" "$SANDBOX_DIR/statsig"
        info "  Seeded statsig/"
    fi
    # Write sandy-required defaults into settings.json (merge with seeded copy)
    SETTINGS_FILE="$SANDBOX_DIR/settings.json"
    [ -f "$SETTINGS_FILE" ] || echo '{}' > "$SETTINGS_FILE"
    # Use node to safely merge JSON (available from the host or as a fallback)
    if command -v node &>/dev/null; then
        node -e "
            const fs = require('fs');
            const f = process.argv[1];
            let raw = fs.readFileSync(f, 'utf8');
            // Fix common JSON issues: trailing commas, missing commas before keys
            raw = raw.replace(/,(\s*[}\]])/g, '\$1');
            raw = raw.replace(/(\"[^\"]*\")\s*\n(\s*\")/g, '\$1,\n\$2');
            let s;
            try { s = JSON.parse(raw); } catch { s = {}; }
            const defaults = {teammateMode:'tmux', spinnerTipsEnabled:false, skipDangerousModePermissionPrompt:true};
            for (const [k,v] of Object.entries(defaults)) { if (!(k in s)) s[k]=v; }
            fs.writeFileSync(f, JSON.stringify(s, null, 2) + '\n');
        " "$SETTINGS_FILE"
    else
        # Fallback: write defaults only if file is empty/bare
        if [ "$(cat "$SETTINGS_FILE")" = "{}" ]; then
            printf '{"teammateMode":"tmux","spinnerTipsEnabled":false,"skipDangerousModePermissionPrompt":true}\n' > "$SETTINGS_FILE"
        fi
    fi
else
    info "Reusing sandbox: $SANDBOX_DIR"
fi

# --- Detect platform ---
OS="$(uname -s)"

# --- Apply LAN-blocking iptables rules (Linux only) ---
PRIVATE_RANGES=(
    "10.0.0.0/8"
    "172.16.0.0/12"
    "192.168.0.0/16"
    "169.254.0.0/16"
    "100.64.0.0/10"
)

apply_network_isolation() {
    if [[ "$OS" == "Linux" ]]; then
        info "Applying network isolation rules..."
        # Test that iptables works before relying on it (fail-closed)
        if ! sudo iptables -L DOCKER-USER -n &>/dev/null; then
            if [[ "${SANDY_ALLOW_NO_ISOLATION:-}" == "1" ]]; then
                warn "WARNING: LAN isolation NOT active (SANDY_ALLOW_NO_ISOLATION=1)."
                return
            fi
            error "Cannot apply network isolation (iptables DOCKER-USER chain not accessible)."
            error "Refusing to start without LAN isolation. To override: SANDY_ALLOW_NO_ISOLATION=1"
            exit 1
        fi

        for range in "${PRIVATE_RANGES[@]}"; do
            sudo iptables -I DOCKER-USER -i "$BRIDGE_NAME" -d "$range" -j DROP 2>/dev/null || true
        done
        # Inserted last → lands at top → evaluated first: allow container's own subnet
        sudo iptables -I DOCKER-USER -i "$BRIDGE_NAME" -d "$CONTAINER_SUBNET" -j ACCEPT 2>/dev/null || true
        info "Network isolation rules applied."
    fi
}

cleanup_network_isolation() {
    if [[ "$OS" == "Linux" ]] && [ -n "$CONTAINER_SUBNET" ]; then
        info "Cleaning up network isolation rules..."
        sudo iptables -D DOCKER-USER -i "$BRIDGE_NAME" -d "$CONTAINER_SUBNET" -j ACCEPT 2>/dev/null || warn "Note: could not remove ACCEPT rule (may already be cleaned)"
        for range in "${PRIVATE_RANGES[@]}"; do
            sudo iptables -D DOCKER-USER -i "$BRIDGE_NAME" -d "$range" -j DROP 2>/dev/null || true
        done
    fi
}

cleanup() {
    cleanup_network_isolation
    # Remove per-instance Docker network
    docker network rm "$NETWORK_NAME" 2>/dev/null || true
    if [ -n "${CRED_TMPDIR:-}" ]; then
        rm -rf "$CRED_TMPDIR"
    fi
    if [ -n "${SSH_RELAY_PID:-}" ]; then
        kill "$SSH_RELAY_PID" 2>/dev/null || true
    fi
}

trap cleanup EXIT INT TERM HUP
apply_network_isolation

# --- Ensure .claude.json exists (setup state: theme, terms acceptance, etc.) ---
# Stored outside SANDBOX_DIR to avoid overlapping Docker bind mounts
CLAUDE_JSON="$SANDY_HOME/sandboxes/${SANDBOX_NAME}.claude.json"
if [ ! -f "$CLAUDE_JSON" ]; then
    # Seed from host's ~/.claude.json (contains onboarding, theme, OAuth, etc.)
    if [ -f "$HOME/.claude.json" ]; then
        cp "$HOME/.claude.json" "$CLAUDE_JSON"
        info "Seeded .claude.json from host"
        # Merge sandy-specific overrides
        if command -v node &>/dev/null; then
            node -e "
                const fs = require('fs');
                const f = process.argv[1];
                let s;
                try { s = JSON.parse(fs.readFileSync(f, 'utf8')); } catch { s = {}; }
                s.tipsDisabled = true;
                s.installMethod = 'native';
                fs.writeFileSync(f, JSON.stringify(s, null, 2) + '\n');
            " "$CLAUDE_JSON"
        fi
    else
        printf '{"tipsDisabled":true,"installMethod":"native"}\n' > "$CLAUDE_JSON"
    fi
else
    # Migrate existing sandboxes: ensure installMethod is native
    if command -v node &>/dev/null; then
        node -e "
            const fs = require('fs');
            const f = process.argv[1];
            let s;
            try { s = JSON.parse(fs.readFileSync(f, 'utf8')); } catch { process.exit(0); }
            if (s.installMethod !== 'native') {
                s.installMethod = 'native';
                fs.writeFileSync(f, JSON.stringify(s, null, 2) + '\n');
            }
        " "$CLAUDE_JSON"
    fi
fi

# --- Ephemeral credential loading (fresh each launch, never persisted in sandbox) ---
CRED_TMPDIR=""
if [ -f "$HOME/.claude/.credentials.json" ]; then
    CRED_TMPDIR="$(mktemp -d)"
    cp "$HOME/.claude/.credentials.json" "$CRED_TMPDIR/.credentials.json"
    chmod 600 "$CRED_TMPDIR/.credentials.json"
    info "Loaded credentials (from file)"
elif [[ "$(uname -s)" == "Darwin" ]]; then
    KEYCHAIN_CREDS="$(security find-generic-password -s "Claude Code-credentials" -a "$(whoami)" -w 2>/dev/null || true)"
    if [ -n "$KEYCHAIN_CREDS" ]; then
        CRED_TMPDIR="$(mktemp -d)"
        printf '%s\n' "$KEYCHAIN_CREDS" > "$CRED_TMPDIR/.credentials.json"
        chmod 600 "$CRED_TMPDIR/.credentials.json"
        info "Loaded credentials (from macOS Keychain)"
    fi
fi

# --- Build docker run flags ---
RUN_FLAGS=(--rm -it)
RUN_FLAGS+=(--cpus "$SANDY_CPUS" --memory "$SANDY_MEM")
RUN_FLAGS+=(--security-opt no-new-privileges:true)
RUN_FLAGS+=(--read-only)
RUN_FLAGS+=(--tmpfs /tmp:size=1G)
RUN_FLAGS+=(--tmpfs /home/claude:size=512M,uid=1001,gid=1001)
RUN_FLAGS+=(--network "$NETWORK_NAME")
RUN_FLAGS+=(-v "$SANDBOX_DIR:/home/claude/.claude")
if [ -n "$CRED_TMPDIR" ]; then
    RUN_FLAGS+=(-v "$CRED_TMPDIR/.credentials.json:/home/claude/.claude/.credentials.json:ro")
fi
RUN_FLAGS+=(-v "$CLAUDE_JSON:/home/claude/.claude.json")
# --- Git submodule support ---
# Submodules use a .git *file* with a relative gitdir: path. Both the forward
# path (worktree→gitdir) and reverse path (gitdir config→worktree) are relative,
# so we must mount the workspace deep enough to preserve the path relationship.
SANDY_WORKSPACE="/workspace"
if [ -f "$WORK_DIR/.git" ]; then
    GITDIR_REL="$(sed 's/^gitdir: //' "$WORK_DIR/.git" | tr -d '[:space:]')"
    if [ -n "$GITDIR_REL" ]; then
        GITDIR_HOST="$(cd "$WORK_DIR" && cd "$GITDIR_REL" && pwd)"
        SUBMODULE_PATHS="$(node -e "
            const path = require('path');
            const rel = process.argv[1], wd = process.argv[2];
            const ups = (rel.match(/\.\.\//g) || []).length;
            const parts = wd.split('/').filter(Boolean);
            const sub = parts.slice(-ups).join('/');
            const ws = '/repo/' + sub;
            const gd = path.resolve(ws, rel);
            console.log(ws); console.log(gd);
        " "$GITDIR_REL" "$WORK_DIR")"
        SANDY_WORKSPACE="$(echo "$SUBMODULE_PATHS" | head -1)"
        CONTAINER_GITDIR="$(echo "$SUBMODULE_PATHS" | tail -1)"
        RUN_FLAGS+=(-v "$GITDIR_HOST:$CONTAINER_GITDIR")
        info "  Git submodule: workspace at $SANDY_WORKSPACE"
    fi
fi
RUN_FLAGS+=(-v "$WORK_DIR:$SANDY_WORKSPACE")
RUN_FLAGS+=(-w "$SANDY_WORKSPACE")
RUN_FLAGS+=(-e "SANDY_WORKSPACE=$SANDY_WORKSPACE")
# Validate SANDY_MODEL — only allow alphanumeric, hyphens, dots, underscores
SANDY_MODEL="${SANDY_MODEL:-claude-opus-4-6}"
if ! [[ "$SANDY_MODEL" =~ ^[a-zA-Z0-9._-]+$ ]]; then
    error "Invalid SANDY_MODEL: $SANDY_MODEL (only alphanumeric, hyphens, dots, underscores allowed)"
    exit 1
fi
RUN_FLAGS+=(-e "SANDY_MODEL=$SANDY_MODEL")
RUN_FLAGS+=(-e "SANDY_SKIP_PERMISSIONS=${SANDY_SKIP_PERMISSIONS:-true}")
# Forward git identity from host
GIT_USER_NAME="${GIT_USER_NAME:-$(git config user.name 2>/dev/null || true)}"
GIT_USER_EMAIL="${GIT_USER_EMAIL:-$(git config user.email 2>/dev/null || true)}"
if [ -n "$GIT_USER_NAME" ]; then
    RUN_FLAGS+=(-e "GIT_USER_NAME=$GIT_USER_NAME")
fi
if [ -n "$GIT_USER_EMAIL" ]; then
    RUN_FLAGS+=(-e "GIT_USER_EMAIL=$GIT_USER_EMAIL")
fi
if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
    RUN_FLAGS+=(-e "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY")
fi

# --- Git authentication ---
# Default (SANDY_SSH=token): use GitHub CLI token with HTTPS — scoped, no SSH agent exposure.
# Opt-in (SANDY_SSH=agent): forward host SSH agent via TCP relay — full agent access.
SANDY_SSH="${SANDY_SSH:-token}"
SSH_RELAY_PID=""

# Mount ~/.ssh/known_hosts for either mode (needed for SSH host verification)
if [ -f "$HOME/.ssh/known_hosts" ]; then
    RUN_FLAGS+=(-v "$HOME/.ssh/known_hosts:/tmp/host-ssh-known_hosts:ro")
fi

if [[ "$SANDY_SSH" == "agent" ]]; then
    # --- SSH agent forwarding (opt-in) ---
    # Mount ~/.ssh read-only at a staging path; entrypoint copies to ~/.ssh with correct ownership.
    if [ -d "$HOME/.ssh" ]; then
        RUN_FLAGS+=(-v "$HOME/.ssh:/tmp/host-ssh:ro")
    fi
    if [ -n "${SSH_AUTH_SOCK:-}" ] && [ -S "${SSH_AUTH_SOCK}" ]; then
        if [[ "$OS" == "Linux" ]]; then
            # Linux: direct socket mount works
            RUN_FLAGS+=(-v "$SSH_AUTH_SOCK:/tmp/ssh-agent.sock")
            RUN_FLAGS+=(-e "SSH_AUTH_SOCK=/tmp/ssh-agent.sock")
        else
            # macOS: start a TCP relay on the host, container connects back via host.docker.internal
            SSH_RELAY_PORTFILE="$(mktemp)"
            if command -v socat &>/dev/null; then
                # Pick an ephemeral port, write it to the portfile, then relay
                python3 -c "import socket; s=socket.socket(); s.bind(('127.0.0.1',0)); print(s.getsockname()[1]); s.close()" > "$SSH_RELAY_PORTFILE"
                SSH_RELAY_PORT="$(cat "$SSH_RELAY_PORTFILE")"
                socat TCP-LISTEN:"$SSH_RELAY_PORT",bind=127.0.0.1,fork,reuseaddr \
                      UNIX-CONNECT:"$SSH_AUTH_SOCK" &
                SSH_RELAY_PID=$!
            elif command -v python3 &>/dev/null; then
                python3 -c "
import socket, os, threading, sys
ssh_sock = os.environ['SSH_AUTH_SOCK']
srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
srv.bind(('127.0.0.1', 0))
srv.listen(5)
with open(sys.argv[1], 'w') as f:
    f.write(str(srv.getsockname()[1]))
def relay(a, b):
    try:
        while True:
            d = a.recv(4096)
            if not d: break
            b.sendall(d)
    except: pass
    finally: a.close(); b.close()
while True:
    tcp, _ = srv.accept()
    unix = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    unix.connect(ssh_sock)
    threading.Thread(target=relay, args=(tcp, unix), daemon=True).start()
    threading.Thread(target=relay, args=(unix, tcp), daemon=True).start()
" "$SSH_RELAY_PORTFILE" &
                SSH_RELAY_PID=$!
            else
                error "SSH agent relay requires socat or python3 on the host."
                exit 1
            fi
            # Wait for the relay to write its port
            for _ in $(seq 1 50); do
                [ -s "$SSH_RELAY_PORTFILE" ] && break
                sleep 0.1
            done
            SSH_RELAY_PORT="$(cat "$SSH_RELAY_PORTFILE" 2>/dev/null || true)"
            rm -f "$SSH_RELAY_PORTFILE"
            if [ -z "$SSH_RELAY_PORT" ]; then
                error "SSH agent relay failed to start."
                kill "$SSH_RELAY_PID" 2>/dev/null || true
                SSH_RELAY_PID=""
                exit 1
            fi
            RUN_FLAGS+=(-e "SSH_RELAY_PORT=$SSH_RELAY_PORT")
            info "SSH agent relay on localhost:$SSH_RELAY_PORT (PID $SSH_RELAY_PID)"
        fi
    else
        warn "SANDY_SSH=agent but no SSH agent found (SSH_AUTH_SOCK not set)"
    fi
    RUN_FLAGS+=(-e "SANDY_SSH=agent")
else
    # --- GitHub token via HTTPS (default) ---
    GIT_TOKEN=""
    if command -v gh &>/dev/null; then
        GIT_TOKEN="$(gh auth token 2>/dev/null || true)"
    fi
    if [ -n "$GIT_TOKEN" ]; then
        RUN_FLAGS+=(-e "GIT_TOKEN=$GIT_TOKEN")
        info "Git auth: GitHub token via gh CLI (HTTPS)"
    else
        warn "No gh CLI token found. Git push/pull may not work."
        warn "Install gh (https://cli.github.com) and run 'gh auth login', or use SANDY_SSH=agent."
    fi
    RUN_FLAGS+=(-e "SANDY_SSH=token")
fi

# --- Launch ---
info "Launching Claude Code sandbox..."
info "  Working directory: $WORK_DIR"
info "  Sandbox:           $SANDBOX_DIR"
info "  Resources:         ${SANDY_CPUS} CPUs, ${SANDY_MEM} memory"
info "  Network:           Public internet only (LAN blocked)"
echo ""

docker run "${RUN_FLAGS[@]}" "$IMAGE_NAME" "$@"
